# R√©cup√©rer l'inventaire d'un item pour √©viter les bugs lors des spam de quantit√©s dans le panier

***

Solution pour √©viter les bugs lorsque les utilisateurs cliquent rapidement sur les boutons d'augmentation/diminution de quantit√© dans le panier, en v√©rifiant l'inventaire disponible avant chaque modification.

## 1. Ajouter un dataset `data-max-quantity` √† l'item

Dans votre fichier `mm-cart-item.liquid`, ajoutez l'attribut `data-max-quantity` avec la quantit√© d'inventaire disponible :

```html
{% comment %} Dans mm-cart-item.liquid {% endcomment %}

<div class="mm-dc-product-container mm-flex mm-column" 
     data-cart-item-id="{{ item.variant_id }}" 
     data-line-index="{{ forloopIndex }}" 
     data-max-quantity="{{ item.product.selected_or_first_available_variant.inventory_quantity }}">
```

### Explication

- `data-max-quantity` : Stocke la quantit√© maximale disponible en inventaire
- `item.product.selected_or_first_available_variant.inventory_quantity` : R√©cup√®re la quantit√© disponible de la variante

## 2. Modifier la fonction `mmDebouncedPushNewQuantity`

Modifiez la fonction pour v√©rifier que la quantit√© ne d√©passe pas le maximum disponible :

```jsx
const mmDebouncedPushNewQuantity = debounce(function (variantId, maxQtty) {
    const quantity = mmGetCartItemQuantity(variantId);

    if (quantity > maxQtty) {
        return;
    }

    mmPushNewQuantity(variantId);
}, 300);
```

### Explication

- La fonction v√©rifie si la quantit√© demand√©e d√©passe le stock disponible
- Si c'est le cas, elle retourne imm√©diatement sans mettre √† jour le panier
- Le `debounce` de 300ms √©vite les appels multiples lors de clics rapides

## 3. Modifier la fonction `mmDecreaseProductQuantity`

Ajoutez la v√©rification de l'inventaire lors de la diminution de quantit√© :

```jsx
function mmDecreaseProductQuantity(variantId) {
    const itemCart = document.querySelector(`[data-cart-item-id="${variantId}"]`); // R√©cup√©ration de l'item card
    const quantity = mmGetCartItemQuantity(variantId); // Corrige l'utilisation de productVariantId -> variantId
    const maxQtty = parseInt(itemCart.dataset.maxQuantity, 10); // R√©cup√©ration du max_quantity de l'item via le dataset
    const newQuantity = quantity - 1;
    
    if (newQuantity > maxQtty) {
        return;
    }
    
    mmSetCartItemQuantity(variantId, newQuantity);
    mmDebouncedPushNewQuantity(variantId, maxQtty);
}
```

### Explication

- R√©cup√®re l'√©l√©ment du panier via `data-cart-item-id`
- Extrait la quantit√© maximale depuis `data-max-quantity`
- V√©rifie que la nouvelle quantit√© ne d√©passe pas le stock
- Met √† jour uniquement si la quantit√© est valide

## 4. Modifier la fonction `mmIncreaseProductQuantity`

Ajoutez la v√©rification de l'inventaire lors de l'augmentation de quantit√© :

```jsx
function mmIncreaseProductQuantity(variantId) {
    const itemCart = document.querySelector(`[data-cart-item-id="${variantId}"]`); // R√©cup√©ration de l'item card
    const quantity = mmGetCartItemQuantity(variantId); // Corrige l'utilisation de productVariantId -> variantId
    const maxQtty = parseInt(itemCart.dataset.maxQuantity, 10); // R√©cup√©ration du max_quantity de l'item via le dataset
    const newQuantity = quantity + 1;
    
    if (newQuantity > maxQtty) {
        return; 
    }

    mmSetCartItemQuantity(variantId, newQuantity);
    mmDebouncedPushNewQuantity(variantId, maxQtty);
}
```

### Explication

- M√™me logique que pour la diminution
- Emp√™che l'ajout de quantit√©s sup√©rieures au stock disponible
- Prot√®ge contre les clics rapides multiples

## 5. R√©sultat

‚úÖ **Plus de bug possible √† cause des √©nerv√©s du click !** üòÑ

## Exemple complet

### Structure HTML (Liquid)

```html
{% comment %} mm-cart-item.liquid {% endcomment %}
<div class="mm-dc-product-container mm-flex mm-column" 
     data-cart-item-id="{{ item.variant_id }}" 
     data-line-index="{{ forloop.index0 }}" 
     data-max-quantity="{{ item.product.selected_or_first_available_variant.inventory_quantity }}">
  
  <div class="mm-cart-item-info">
    <h3>{{ item.product.title }}</h3>
    <p>{{ item.variant.title }}</p>
  </div>
  
  <div class="mm-cart-item-quantity">
    <button onclick="mmDecreaseProductQuantity({{ item.variant_id }})">-</button>
    <span class="mm-quantity-display">{{ item.quantity }}</span>
    <button onclick="mmIncreaseProductQuantity({{ item.variant_id }})">+</button>
  </div>
  
</div>
```

### Code JavaScript complet

```jsx
// Fonction de debounce
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Fonction pour r√©cup√©rer la quantit√© actuelle
function mmGetCartItemQuantity(variantId) {
    const itemCart = document.querySelector(`[data-cart-item-id="${variantId}"]`);
    const quantityInput = itemCart.querySelector('.mm-quantity-display');
    return parseInt(quantityInput.textContent, 10) || 0;
}

// Fonction pour d√©finir la quantit√©
function mmSetCartItemQuantity(variantId, quantity) {
    const itemCart = document.querySelector(`[data-cart-item-id="${variantId}"]`);
    const quantityInput = itemCart.querySelector('.mm-quantity-display');
    quantityInput.textContent = quantity;
}

// Fonction pour pousser la nouvelle quantit√© (avec v√©rification)
const mmDebouncedPushNewQuantity = debounce(function (variantId, maxQtty) {
    const quantity = mmGetCartItemQuantity(variantId);

    if (quantity > maxQtty) {
        return;
    }

    mmPushNewQuantity(variantId);
}, 300);

// Fonction pour diminuer la quantit√©
function mmDecreaseProductQuantity(variantId) {
    const itemCart = document.querySelector(`[data-cart-item-id="${variantId}"]`);
    const quantity = mmGetCartItemQuantity(variantId);
    const maxQtty = parseInt(itemCart.dataset.maxQuantity, 10);
    const newQuantity = quantity - 1;
    
    if (newQuantity > maxQtty) {
        return;
    }
    
    mmSetCartItemQuantity(variantId, newQuantity);
    mmDebouncedPushNewQuantity(variantId, maxQtty);
}

// Fonction pour augmenter la quantit√©
function mmIncreaseProductQuantity(variantId) {
    const itemCart = document.querySelector(`[data-cart-item-id="${variantId}"]`);
    const quantity = mmGetCartItemQuantity(variantId);
    const maxQtty = parseInt(itemCart.dataset.maxQuantity, 10);
    const newQuantity = quantity + 1;
    
    if (newQuantity > maxQtty) {
        return; 
    }

    mmSetCartItemQuantity(variantId, newQuantity);
    mmDebouncedPushNewQuantity(variantId, maxQtty);
}
```

## Bonnes pratiques

### Gestion des erreurs

1. **V√©rifier que l'√©l√©ment existe** avant d'acc√©der √† ses propri√©t√©s
2. **G√©rer les cas o√π `inventory_quantity` est null** ou ind√©fini
3. **Afficher un message** √† l'utilisateur si le stock est insuffisant

### Am√©lioration possible

```jsx
function mmIncreaseProductQuantity(variantId) {
    const itemCart = document.querySelector(`[data-cart-item-id="${variantId}"]`);
    
    if (!itemCart) {
        console.error('Item cart not found');
        return;
    }
    
    const quantity = mmGetCartItemQuantity(variantId);
    const maxQtty = parseInt(itemCart.dataset.maxQuantity, 10) || 0;
    const newQuantity = quantity + 1;
    
    if (newQuantity > maxQtty) {
        // Afficher un message √† l'utilisateur
        alert(`Stock insuffisant. Quantit√© disponible : ${maxQtty}`);
        return; 
    }

    mmSetCartItemQuantity(variantId, newQuantity);
    mmDebouncedPushNewQuantity(variantId, maxQtty);
}
```

## Cas particuliers

### Produits sans gestion d'inventaire

Si un produit n'a pas de gestion d'inventaire, `inventory_quantity` peut √™tre `null`. Dans ce cas :

```liquid
data-max-quantity="{% if item.product.selected_or_first_available_variant.inventory_quantity %}{{ item.product.selected_or_first_available_variant.inventory_quantity }}{% else %}9999{% endif %}"
```

### Mise √† jour en temps r√©el

Si l'inventaire change pendant que l'utilisateur est sur la page, vous devrez peut-√™tre mettre √† jour `data-max-quantity` apr√®s chaque modification du panier.

## Limitations

- Cette solution fonctionne c√¥t√© client et peut √™tre contourn√©e
- Pour une s√©curit√© maximale, validez √©galement c√¥t√© serveur lors de l'ajout au panier
- L'inventaire peut changer entre le chargement de la page et l'ajout au panier

## Ressources

- **Shopify Liquid** : [Variants](https://shopify.dev/docs/api/liquid/objects/product#product-selected_or_first_available_variant)
- **Debounce** : Technique pour limiter les appels de fonction

